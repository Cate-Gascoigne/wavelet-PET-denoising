import os
import pywt
import numpy as np
import nibabel as nib
from keras.layers import PReLU
import warnings
warnings.filterwarnings("ignore")
from networks.FCN_3D import SR_UnetGAN_3D


class WaveletPredictor:
    def __init__(
        self,
        # List of paths containing test low-dose PET images with different DRFs.
        lowdose_dirs,
        # Path of PET reconstructions generated by model.
        recn_path,
        # Path of trained 3D-UNet approximation model.
        model_path_approx,
        # Path of trained 3D-UNet detail model.
        model_path_detail,
        # Epoch number of approximation model to be used.
        epoch_approx,
        # Epoch number of detail model to be used.
        epoch_detail,
    ):
        self.lowdose_dirs = lowdose_dirs
        self.recn_path = recn_path
        # Init wavelet approximation model
        self.A_unet = SR_UnetGAN_3D(img_shape=(1, 64, 64, 64))  
        self.A_unet.generator.load_weights(os.path.join(model_path_approx, 'generator_epoch_' + str(epoch_approx) + '.hdf5'))
        # Init wavelet detail model
        self.D_unet = SR_UnetGAN_3D(img_shape=(1, 64, 64, 64), activation=PReLU)  
        self.D_unet.generator.load_weights(os.path.join(model_path_detail, 'generator_epoch_' + str(epoch_detail) + '.hdf5'))

    def _load_subject(self, lowdose_dir, subject, is_explorer=False):
        """
        Load a single test lowdose array.
        :param lowdose_dir: Directory containing lowdose test PETs with a specific DRF.
        :param subject: Subject nifti file name, in forms of PID.nii.gz.
        :param is_explorer: Boolean value indicating if current data from explorer scanner, in which case only
        even number of slices are loaded by ignoring the last slice.
        :return: Subject filename, subject affine, and lowdose array.
        """
        while True:
            # Load lowdose test data
            low_array = nib.load(os.path.join(lowdose_dir, subject)).get_fdata()
            affine = nib.load(os.path.join(lowdose_dir, subject)).affine
            # Test if using explorer scanner 
            if is_explorer: 
                yield subject, affine, low_array[:,:,:-1]
            else:
                yield subject, affine, low_array

    def _normalize(self, data):
        """
        Normalize input array to (-1, 1).
        :param data: Numpy array consisting of a PET image.
        :return: Normalized data, and tuple of (minimum, range) used for denormalization.
        """
        d_max, d_min = np.max(data), np.min(data)
        d_range = d_max - d_min
        data = np.where(data >= 0, data / d_max, data / (-d_min))
        return data, (d_min, d_range)

    def _denormalize(self, data, d_min, d_range):
        """
        Denormalize input array from (-1, 1) back to original spacing.
        :param data: Normalized numpy array a PET image.
        :param d_min: Minimum value used while normalization.
        :param d_range: Range value used while normalization.
        :return: Denormalized PET image array.
        """
        d_max = d_range - (-d_min)
        data = np.where(data >= 0, data * d_max, data * (-d_min))
        return data

    def _wavelet_decompose(self, PET, level=1, wavelet='haar', mode='symmetric', axes=(-3, -2, -1)):
        """
        Wavelet decomposition to subject PET image.
        :param PET: Array of subject 3d PET image, has shape of (x=440, y=440, z=644) for siemens scanner data.
        :param level: Wavelet decomposition level, by default set to 1.
        :param wavelet: Wavelet filterbank name, by default set to 'haar'.
        :param mode: Wavelet decomposition mode, by default set to 'symmetric'.
        :param axes: Axes against which the wavelet decomposition is applied, by default set to (-3, -2, -1), which
        indicates (x, y, z) positioned in the end.
        :return: Both decomposed approximation and detail coefficients, in case of wavelet level equals 1, the 
        approximation coeff has shape of (1, x/2, y/2, z/2), and the detail coeff has shape of (7, x/2, y/2, z/2).
        """
        coeffs = pywt.wavedecn(data=PET, wavelet=wavelet, level=level, mode=mode, axes=axes)
        # Extract level_n (lowerst) approximation and detail coeffs
        approx, detail = coeffs[0], coeffs[1]  
        x, y, z = approx.shape
        approx_decomposed, detail_decomposed = np.empty((0, x, y, z)), np.empty((0, x, y, z)) 

        # Append only approximation coeff
        approx_decomposed = np.append(approx_decomposed, approx[np.newaxis,], axis=0)
        # Append detail coeffs in fixed order
        keys = [ 'aad', 'ada', 'dad', 'dda', 'daa', 'ddd', 'add'] 
        for key in keys:
            detail_decomposed = np.append(detail_decomposed, detail[key][np.newaxis,], axis=0)
        return approx_decomposed, detail_decomposed

    def _from_small_path(self, PET, generator, patch_size=64):
        """
        Apply generator model to small patches. 
        Patches are extracted and re-generated along x, y, z axes in a sliding window fashion. 
        :param PET: Lowdose PET image to be enhanced in shape of (x, y, z).
        :param generator: UNet 3D generator with weights loaded.
        :param patch_size: Volume shape of small patch, by default set to 64. 
        :return: PET image enhanced by model.
        """
        stride = patch_size // 4
        i_x, i_y, i_z = PET.shape
        volume = np.zeros(shape=PET.shape) 
        count_matrix = np.zeros(shape=PET.shape)
        for z in range((i_z - patch_size) // stride + 1):
            for x in range((i_x - patch_size) // stride + 1):
                for y in range((i_y - patch_size) // stride + 1):
                    x_patch = PET[x*stride:x*stride+patch_size, y*stride:y*stride+patch_size, z*stride:z*stride+patch_size]
                    x_patch = np.expand_dims(x_patch, axis=0)
                    x_patch = np.expand_dims(x_patch, axis=0)
                    # Apply generator model to small patch
                    patch = generator.predict(x_patch)[0,0,:,:,:]
                    volume[x*stride:x*stride+patch_size, y*stride:y*stride+patch_size, z*stride:z*stride+patch_size] += patch
                    count_matrix[x*stride:x*stride+patch_size, y*stride:y*stride+patch_size, z*stride:z*stride+patch_size] += np.ones(patch.shape)
        volume /= count_matrix
        volume = np.nan_to_num(volume)
        return volume

    def load_test_dataset(self, lowdose_dir, subject):
        """
        Prepare a subject test dataset.
        :param lowdose_dir: Directory containing all test subjects with a specific DRF.
        :param subejct: Nifti file name of a test subject.
        :return: Normalized approximation and detail coefficients, their minimum, range values used while 
        normalization, subject lowdose array and subject affine. 
        """
        # Load test data and test whether scanned from explorer 
        subject, affine, low_array = next(self._load_subject(
            lowdose_dir=lowdose_dir, 
            subject=subject,
            is_explorer='Anonymous' in subject
        ))
        print('Loading test subject data ' + str(subject)) 
        # Wavelet tranform 
        approx_noisy, detail_noisy = self._wavelet_decompose(PET=low_array)
        print('Conducting wavelet transform to shape ' + str(approx_noisy.shape) + ':' + str(detail_noisy.shape))
        # Normalization
        approx_noisy, (approx_min, approx_range) = self._normalize(data=approx_noisy)
        detail_noisy, (detail_min, detail_range) = self._normalize(data=detail_noisy)
        print('Normalization to (-1, 1)')
        return (approx_noisy, approx_min, approx_range), (detail_noisy, detail_min, detail_range), low_array, affine

    def apply_generator(self, PET, generator):
        """
        Apply generator model to coefficient. 
        :param PET: Lowdose PET coefficient to be enhanced in shape of (N, x, y, z).
        :param generator: Generator model for denoising, either for approximation or for detail coefficient.
        :return: PET image enhanced.
        """
        _, x, y, z = PET.shape
        restored = np.empty((0, x, y, z))
        for d_PET in PET:
            dPET_restored = self._from_small_path(
                PET=d_PET,
                generator=generator
            )
            restored = np.append(restored, dPET_restored[np.newaxis,], axis=0)
        return np.squeeze(restored)

    def post_processing(self, approx_restored, detail_restored, test_noisy, min_approx, min_detail, range_approx, range_detail, wt_level=1):
        """
        Wavelet reconstruction using enhanced coefficients.
        :param approx_restored: Enhanced approximation coefficient outputted from approx model.
        :param detail_restored: Enhanced detail coefficient outputted from detail model.
        :param test_noisy: Input noisy PET used as a basis of wavelet reconstruction.
        :param min_approx: Minimum value used while normalization for approximation coefficient.
        :param min_detail: Minimum value used while normalization for detail coefficient.
        :param range_approx: Range value used while normalization for approximation coefficient.
        :param range_detail: Range value used while normalization for detail coefficient.
        :return: Wavelet PET reconstruction using enhanced coefficients.
        """
        # Clip non-valid value
        approx_restored = np.clip(approx_restored, 0.0, 1.0)
        detail_restored = np.clip(detail_restored, -1.0, 1.0)
        # De-normalization
        approx_restored = self._denormalize(data=approx_restored, d_min=min_approx, d_range=range_approx)
        detail_restored = self._denormalize(data=detail_restored, d_min=min_detail, d_range=range_detail)

        # Wavelet reconstruction with replaced approximation and detail coeffs
        coeffs = pywt.wavedecn(data=test_noisy, wavelet='haar', level=wt_level, mode='symmetric', axes=(-3, -2, -1))
        coeffs[0] = approx_restored
        det = {}
        keys = [ 'aad', 'ada', 'dad', 'dda', 'daa', 'ddd', 'add'] 
        for i, value in enumerate(detail_restored):
            det[keys[i]] = value
        coeffs[1] = det
        noisy_recn = pywt.waverecn(coeffs=coeffs, wavelet='haar', mode='symmetric', axes=(-3, -2, -1))

        # Reset background
        noisy_recn[np.where(test_noisy == 0)] = 0
        # Remove negative values
        noisy_recn = np.clip(noisy_recn, 0.0, np.max(noisy_recn))
        return noisy_recn

    def save_subject_recn(self, data, subject, subject_affine, save_dir):
        """
        Save PET reconstruction to Nifti file.
        :param data: PET image enhanced by model.
        :param subject: Nifti file name of a test subject.
        :param subject_affine: Numpy array of subject affine.
        :param save_dir: Directory storing output Nifti file.
        """
        # Padding the losing slice at end if is explorer data
        is_explorer = 'Anonymous' in subject
        if is_explorer:
            data = np.pad(data, ((0,0), (0,0), (0,1)), 'constant')
        nii = nib.Nifti1Image(data, affine=subject_affine)
        nib.save(nii, os.path.join(save_dir, subject))

    def predict_all(self):
        """Apply model to all listed lowdose directories"""
        for lowdose_dir in self.lowdose_dirs:
            DRF = os.path.basename(os.path.normpath(lowdose_dir))
            print('--------------- ' + DRF + ' -----------------')
            save_dir = os.path.join(self.recn_path, str(DRF))
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            for subject in os.listdir(lowdose_dir):
                (ds_approx, min_approx, range_approx), (ds_detail, min_detail, range_detail), ds_noisy, affine = self.load_test_dataset(lowdose_dir, subject)
                print('Applying approximation model...')
                approx_restored = self.apply_generator(PET=ds_approx, generator=self.A_unet.generator)
                print('Applying detail model...')
                detail_restored = self.apply_generator(PET=ds_detail, generator=self.D_unet.generator)
                noisy_recn = self.post_processing(
                    approx_restored=approx_restored, 
                    detail_restored=detail_restored, 
                    test_noisy=ds_noisy, 
                    min_approx=min_approx, 
                    min_detail=min_detail, 
                    range_approx=range_approx, 
                    range_detail=range_detail
                )
                self.save_subject_recn(noisy_recn, subject, affine, save_dir=save_dir)
